<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>brlang - ãƒ–ãƒ©ã‚¦ã‚¶ã§å‹•ããƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èª</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .editor-section {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #34495e;
        }
        #codeInput {
            width: 100%;
            height: 200px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            padding: 15px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            background-color: #fafafa;
            resize: vertical;
        }
        #codeInput:focus {
            outline: none;
            border-color: #3498db;
        }
        .buttons {
            text-align: center;
            margin: 20px 0;
        }
        #runButton {
            background-color: #27ae60;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #runButton:hover {
            background-color: #219a52;
        }
        #runButton:active {
            transform: translateY(1px);
        }
        .output-section {
            margin-top: 30px;
        }
        #output {
            width: 100%;
            height: 150px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            padding: 15px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            background-color: #2c3e50;
            color: #ecf0f1;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .sample-code {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #3498db;
        }
        #tokens {
            width: 100%;
            height: 120px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            padding: 15px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            background-color: #ecf0f1;
            color: #2c3e50;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        #tokenizeButton {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px;
            transition: background-color 0.3s;
        }
        
        #tokenizeButton:hover {
            background-color: #2980b9;
        }

        #ast {
            width: 100%;
            height: 100px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            padding: 15px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            background-color: #f8f9fa;
            color: #2c3e50;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        #parseButton {
            background-color: #9b59b6;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px;
            transition: background-color 0.3s;
        }
        
        #parseButton:hover {
            background-color: #8e44ad;
        }
    </style>
</head>
<body>
  <div class="container">
      <h1>ğŸš€ brlang å®Ÿè¡Œç’°å¢ƒ</h1>
      
      <div class="editor-section">
          <label for="codeInput">brlangã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›:</label>
          <textarea id="codeInput" placeholder="ã“ã“ã«brlangã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ãã ã•ã„...
  
  ä¾‹:
  5 + 3 * 2
  (10 - 6) / 2
  -5 + 3
  print(&quot;Hello&quot;)"></textarea>
      </div>
      
      <div class="buttons">
          <button id="runButton">â–¶ï¸ å®Ÿè¡Œ</button>
          <button id="tokenizeButton">ğŸ” ãƒˆãƒ¼ã‚¯ãƒ³è§£æ</button>
          <button id="parseButton">ğŸŒ³ æ§‹æ–‡è§£æ</button>
      </div>
      
      <!-- æ§‹æ–‡æœ¨è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’è¿½åŠ  -->
      <div class="output-section">
          <label for="ast">æ§‹æ–‡æœ¨:</label>
          <div id="ast"></div>
      </div>
      
      <div class="output-section">
          <label for="tokens">ãƒˆãƒ¼ã‚¯ãƒ³è§£æçµæœ:</label>
          <div id="tokens"></div>
      </div>
      
      <div class="output-section">
          <label for="output">å®Ÿè¡Œçµæœ:</label>
          <div id="output"></div>
      </div>
      
      <div class="sample-code">
          <strong>ğŸ’¡ è©¦ã—ã¦ã¿ã‚ˆã†:</strong><br>
          <code>5 + 3 * 2</code> ã¨å…¥åŠ›ã—ã¦ã€Œæ§‹æ–‡è§£æã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã¿ã¦ãã ã•ã„ã€‚<br>
          æ¼”ç®—å­ã®å„ªå…ˆé †ä½ãŒã©ã®ã‚ˆã†ã«å‡¦ç†ã•ã‚Œã‚‹ã‹ã‚’ç¢ºèªã§ãã¾ã™ã€‚
      </div>
  </div>
  <script>
  // ã“ã“ã«JavaScriptã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ã„ãã¾ã™

  // ãƒˆãƒ¼ã‚¯ãƒ³ã®ç¨®é¡ã‚’å®šç¾©
  const TokenType = {
      // ãƒªãƒ†ãƒ©ãƒ«ï¼ˆå€¤ï¼‰
      NUMBER: 'NUMBER',           // 123, 45.67
      STRING: 'STRING',           // "Hello", 'World'
      IDENTIFIER: 'IDENTIFIER',   // å¤‰æ•°åã€é–¢æ•°å
      
      // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
      LET: 'LET',                // let
      PRINT: 'PRINT',            // print
      
      // æ¼”ç®—å­
      PLUS: 'PLUS',              // +
      MINUS: 'MINUS',            // -
      MULTIPLY: 'MULTIPLY',      // *
      DIVIDE: 'DIVIDE',          // /
      ASSIGN: 'ASSIGN',          // =
      
      // åŒºåˆ‡ã‚Šæ–‡å­—
      LPAREN: 'LPAREN',          // (
      RPAREN: 'RPAREN',          // )
      COMMA: 'COMMA',            // ,
      
      // ç‰¹æ®Š
      NEWLINE: 'NEWLINE',        // æ”¹è¡Œ
      EOF: 'EOF'                 // ãƒ•ã‚¡ã‚¤ãƒ«çµ‚ç«¯
  };
  
  // ãƒˆãƒ¼ã‚¯ãƒ³ã‚¯ãƒ©ã‚¹
  class Token {
      constructor(type, value, line = 0, column = 0) {
          this.type = type;      // ãƒˆãƒ¼ã‚¯ãƒ³ã®ç¨®é¡
          this.value = value;    // ãƒˆãƒ¼ã‚¯ãƒ³ã®å€¤
          this.line = line;      // è¡Œç•ªå·ï¼ˆã‚¨ãƒ©ãƒ¼è¡¨ç¤ºç”¨ï¼‰
          this.column = column;  // åˆ—ç•ªå·ï¼ˆã‚¨ãƒ©ãƒ¼è¡¨ç¤ºç”¨ï¼‰
      }
      
      toString() {
          return `Token(${this.type}, "${this.value}")`;
      }
  }
  
  // ãƒ¬ã‚­ã‚µãƒ¼ï¼ˆå­—å¥è§£æå™¨ï¼‰ã‚¯ãƒ©ã‚¹
  class Lexer {
      constructor(text) {
          this.text = text;           // è§£æã™ã‚‹æ–‡å­—åˆ—
          this.position = 0;          // ç¾åœ¨ã®ä½ç½®
          this.line = 1;              // ç¾åœ¨ã®è¡Œç•ªå·
          this.column = 1;            // ç¾åœ¨ã®åˆ—ç•ªå·
          this.currentChar = this.text[this.position] || null;
      }
      
      // ç¾åœ¨ä½ç½®ã‚’1ã¤é€²ã‚ã‚‹
      advance() {
          if (this.currentChar === '\n') {
              this.line++;
              this.column = 1;
          } else {
              this.column++;
          }
          
          this.position++;
          this.currentChar = this.position < this.text.length ? 
                            this.text[this.position] : null;
      }
      
      // ç©ºç™½æ–‡å­—ã‚’ã‚¹ã‚­ãƒƒãƒ—
      skipWhitespace() {
          while (this.currentChar && /\s/.test(this.currentChar) && this.currentChar !== '\n') {
              this.advance();
          }
      }
      
      // æ•°å€¤ã‚’èª­ã¿å–ã‚‹
      readNumber() {
          let number = '';
          let startColumn = this.column;
          
          while (this.currentChar && /[0-9.]/.test(this.currentChar)) {
              number += this.currentChar;
              this.advance();
          }
          
          return new Token(TokenType.NUMBER, parseFloat(number), this.line, startColumn);
      }
      
      // æ–‡å­—åˆ—ã‚’èª­ã¿å–ã‚‹
      readString() {
          let string = '';
          let quote = this.currentChar; // " ã¾ãŸã¯ '
          let startColumn = this.column;
          
          this.advance(); // é–‹å§‹ã‚¯ã‚©ãƒ¼ãƒˆã‚’ã‚¹ã‚­ãƒƒãƒ—
          
          while (this.currentChar && this.currentChar !== quote) {
              string += this.currentChar;
              this.advance();
          }
          
          if (this.currentChar === quote) {
              this.advance(); // çµ‚äº†ã‚¯ã‚©ãƒ¼ãƒˆã‚’ã‚¹ã‚­ãƒƒãƒ—
          }
          
          return new Token(TokenType.STRING, string, this.line, startColumn);
      }
      
      // è­˜åˆ¥å­ï¼ˆå¤‰æ•°åã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰ã‚’èª­ã¿å–ã‚‹
      readIdentifier() {
          let identifier = '';
          let startColumn = this.column;
          
          while (this.currentChar && /[a-zA-Z_][a-zA-Z0-9_]*/.test(this.currentChar)) {
              identifier += this.currentChar;
              this.advance();
          }
          
          // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
          const keywords = {
              'let': TokenType.LET,
              'print': TokenType.PRINT
          };
          
          const tokenType = keywords[identifier] || TokenType.IDENTIFIER;
          return new Token(tokenType, identifier, this.line, startColumn);
      }
      
      // æ¬¡ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
      getNextToken() {
          while (this.currentChar) {
              // ç©ºç™½ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆæ”¹è¡Œä»¥å¤–ï¼‰
              if (/\s/.test(this.currentChar) && this.currentChar !== '\n') {
                  this.skipWhitespace();
                  continue;
              }
              
              // æ”¹è¡Œ
              if (this.currentChar === '\n') {
                  const token = new Token(TokenType.NEWLINE, '\n', this.line, this.column);
                  this.advance();
                  return token;
              }
              
              // æ•°å€¤
              if (/[0-9]/.test(this.currentChar)) {
                  return this.readNumber();
              }
              
              // æ–‡å­—åˆ—
              if (this.currentChar === '"' || this.currentChar === "'") {
                  return this.readString();
              }
              
              // è­˜åˆ¥å­ãƒ»ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
              if (/[a-zA-Z_]/.test(this.currentChar)) {
                  return this.readIdentifier();
              }
              
              // å˜ä¸€æ–‡å­—ãƒˆãƒ¼ã‚¯ãƒ³
              const char = this.currentChar;
              const line = this.line;
              const column = this.column;
              
              this.advance();
              
              switch (char) {
                  case '+': return new Token(TokenType.PLUS, char, line, column);
                  case '-': return new Token(TokenType.MINUS, char, line, column);
                  case '*': return new Token(TokenType.MULTIPLY, char, line, column);
                  case '/': return new Token(TokenType.DIVIDE, char, line, column);
                  case '=': return new Token(TokenType.ASSIGN, char, line, column);
                  case '(': return new Token(TokenType.LPAREN, char, line, column);
                  case ')': return new Token(TokenType.RPAREN, char, line, column);
                  case ',': return new Token(TokenType.COMMA, char, line, column);
                  default:
                      throw new Error(`ä¸æ­£ãªæ–‡å­—: '${char}' (è¡Œ${line}, åˆ—${column})`);
              }
          }
          
          return new Token(TokenType.EOF, null, this.line, this.column);
      }
      
      // ã™ã¹ã¦ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
      getAllTokens() {
          const tokens = [];
          let token = this.getNextToken();
          
          while (token.type !== TokenType.EOF) {
              tokens.push(token);
              token = this.getNextToken();
          }
          
          tokens.push(token); // EOF ãƒˆãƒ¼ã‚¯ãƒ³ã‚‚è¿½åŠ 
          return tokens;
      }
  }

  // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ï¼ˆè¨ˆç®—æ©Ÿï¼‰ã‚¯ãƒ©ã‚¹
  class Calculator {
      // æ•°å€¤ãƒãƒ¼ãƒ‰ã‚’å‡¦ç†
      visitNumber(node) {
          return node.value;
      }
      
      // äºŒé …æ¼”ç®—ãƒãƒ¼ãƒ‰ã‚’å‡¦ç†
      visitBinaryOp(node) {
          const leftValue = node.left.accept(this);
          const rightValue = node.right.accept(this);
          
          switch (node.operator.type) {
              case TokenType.PLUS:
                  return leftValue + rightValue;
              case TokenType.MINUS:
                  return leftValue - rightValue;
              case TokenType.MULTIPLY:
                  return leftValue * rightValue;
              case TokenType.DIVIDE:
                  if (rightValue === 0) {
                      throw new Error('ã‚¼ãƒ­ã§å‰²ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
                  }
                  return leftValue / rightValue;
              default:
                  throw new Error(`Unknown operator: ${node.operator.type}`);
          }
      }
      
      // å˜é …æ¼”ç®—ãƒãƒ¼ãƒ‰ã‚’å‡¦ç†
      visitUnaryOp(node) {
          const operandValue = node.operand.accept(this);
          
          switch (node.operator.type) {
              case TokenType.PLUS:
                  return +operandValue;
              case TokenType.MINUS:
                  return -operandValue;
              default:
                  throw new Error(`Unknown unary operator: ${node.operator.type}`);
          }
      }
      
      // è¨ˆç®—å®Ÿè¡Œ
      calculate(ast) {
          if (!ast) {
              return null;
          }
          return ast.accept(this);
      }
  }
  
  // brlang ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ v0.3
  class BrlangInterpreter {
      constructor() {
          this.outputElement = document.getElementById('output');
          this.tokensElement = document.getElementById('tokens');
          this.astElement = document.getElementById('ast');
          this.calculator = new Calculator();
      }
      
      // çµæœã‚’ç”»é¢ã«è¡¨ç¤ºã™ã‚‹é–¢æ•°
      print(message) {
          this.outputElement.textContent += message + '\n';
      }
      
      // å„ã‚¨ãƒªã‚¢ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹é–¢æ•°
      clearOutput() {
          this.outputElement.textContent = '';
      }
      
      clearTokens() {
          this.tokensElement.textContent = '';
      }
      
      clearAST() {
          this.astElement.textContent = '';
      }
      
      // æ§‹æ–‡æœ¨ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
      showAST(ast) {
          this.clearAST();
          if (ast) {
              this.astElement.textContent = 'æ§‹æ–‡æœ¨:\n\n' + ast.toString();
          } else {
              this.astElement.textContent = 'æ§‹æ–‡æœ¨: ãªã—';
          }
      }
      
      // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
      showTokens(tokens) {
          this.clearTokens();
          this.tokensElement.textContent = 'ãƒˆãƒ¼ã‚¯ãƒ³è§£æçµæœ:\n\n';
          
          tokens.forEach((token, index) => {
              this.tokensElement.textContent += 
                  `${index + 1}. ${token.toString()}\n`;
          });
      }
      
      // ãƒˆãƒ¼ã‚¯ãƒ³è§£æã®ã¿ã‚’å®Ÿè¡Œ
      tokenize(code) {
          try {
              const lexer = new Lexer(code);
              const tokens = lexer.getAllTokens();
              this.showTokens(tokens);
              return tokens;
          } catch (error) {
              this.clearTokens();
              this.tokensElement.textContent = `ãƒˆãƒ¼ã‚¯ãƒ³è§£æã‚¨ãƒ©ãƒ¼: ${error.message}`;
              return null;
          }
      }
      
      // æ§‹æ–‡è§£æã®ã¿ã‚’å®Ÿè¡Œ
      parse(code) {
          try {
              const tokens = this.tokenize(code);
              if (!tokens) return null;
              
              const parser = new Parser(tokens);
              const ast = parser.parse();
              this.showAST(ast);
              return ast;
          } catch (error) {
              this.clearAST();
              this.astElement.textContent = `æ§‹æ–‡è§£æã‚¨ãƒ©ãƒ¼: ${error.message}`;
              return null;
          }
      }
      
      // brlangã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°
      execute(code) {
          this.clearOutput();
          
          try {
              const lexer = new Lexer(code);
              const tokens = lexer.getAllTokens();
              
              // printæ–‡ã®å‡¦ç†
              if (this.isPrintStatement(tokens)) {
                  this.executePrintStatement(tokens);
                  return;
              }
              
              // æ•°å¼ã®è¨ˆç®—
              const parser = new Parser(tokens);
              const ast = parser.parse();
              
              if (ast) {
                  const result = this.calculator.calculate(ast);
                  this.print(`çµæœ: ${result}`);
                  this.showAST(ast);
              } else {
                  this.print('è¨ˆç®—ã™ã‚‹å¼ãŒã‚ã‚Šã¾ã›ã‚“');
              }
              
          } catch (error) {
              this.print(`å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: ${error.message}`);
          }
      }
      
      // printæ–‡ã‹ã©ã†ã‹ã‚’åˆ¤å®š
      isPrintStatement(tokens) {
          return tokens.length > 0 && tokens[0].type === TokenType.PRINT;
      }
      
      // printæ–‡ã‚’å®Ÿè¡Œ
      executePrintStatement(tokens) {
          let i = 0;
          
          if (tokens[i].type === TokenType.PRINT) {
              i++; // print
              
              if (i < tokens.length && tokens[i].type === TokenType.LPAREN) {
                  i++; // (
                  
                  // å¼•æ•°ã‚’å–å¾—
                  if (i < tokens.length) {
                      const arg = tokens[i];
                      
                      if (arg.type === TokenType.STRING) {
                          this.print(arg.value);
                      } else if (arg.type === TokenType.NUMBER) {
                          this.print(arg.value.toString());
                      } else {
                          this.print(`ã‚¨ãƒ©ãƒ¼: æœªå¯¾å¿œã®å¼•æ•°ã‚¿ã‚¤ãƒ— ${arg.type}`);
                      }
                      
                      i++; // å¼•æ•°
                  }
                  
                  if (i < tokens.length && tokens[i].type === TokenType.RPAREN) {
                      i++; // )
                  }
              }
          }
      }
  }
  
  // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
  const interpreter = new BrlangInterpreter();
  
  // ãƒšãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã¨ãã®å‡¦ç†
  document.addEventListener('DOMContentLoaded', function() {
      const runButton = document.getElementById('runButton');
      const tokenizeButton = document.getElementById('tokenizeButton');
      const parseButton = document.getElementById('parseButton');
      const codeInput = document.getElementById('codeInput');
      
      // å®Ÿè¡Œãƒœã‚¿ãƒ³
      runButton.addEventListener('click', function() {
          const code = codeInput.value;
          interpreter.execute(code);
      });
      
      // ãƒˆãƒ¼ã‚¯ãƒ³è§£æãƒœã‚¿ãƒ³
      tokenizeButton.addEventListener('click', function() {
          const code = codeInput.value;
          interpreter.tokenize(code);
      });
      
      // æ§‹æ–‡è§£æãƒœã‚¿ãƒ³
      parseButton.addEventListener('click', function() {
          const code = codeInput.value;
          interpreter.parse(code);
      });
      
      // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
      codeInput.addEventListener('keydown', function(event) {
          if (event.ctrlKey && event.key === 'Enter') {
              interpreter.execute(codeInput.value);
          } else if (event.ctrlKey && event.key === 't') {
              event.preventDefault();
              interpreter.tokenize(codeInput.value);
          } else if (event.ctrlKey && event.key === 'p') {
              event.preventDefault();
              interpreter.parse(codeInput.value);
          }
      });
      
      // åˆæœŸè¡¨ç¤ºãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
      interpreter.print('brlang å®Ÿè¡Œç’°å¢ƒ v0.3 ã¸ã‚ˆã†ã“ãï¼');
      interpreter.print('æ–°æ©Ÿèƒ½: å››å‰‡æ¼”ç®—ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸï¼');
      interpreter.print('ä¾‹: 5 + 3 * 2 ã‚’å…¥åŠ›ã—ã¦å®Ÿè¡Œã—ã¦ã¿ã¦ãã ã•ã„ã€‚');
      interpreter.print('');
  });
  
  // ASTãƒãƒ¼ãƒ‰ï¼ˆæ§‹æ–‡æœ¨ã®ãƒãƒ¼ãƒ‰ï¼‰ã®åŸºåº•ã‚¯ãƒ©ã‚¹
  class ASTNode {
      accept(visitor) {
          throw new Error('accept method must be implemented');
      }
  }
  
  // æ•°å€¤ãƒãƒ¼ãƒ‰
  class NumberNode extends ASTNode {
      constructor(token) {
          super();
          this.token = token;
          this.value = token.value;
      }
      
      accept(visitor) {
          return visitor.visitNumber(this);
      }
      
      toString() {
          return `NumberNode(${this.value})`;
      }
  }
  
  // äºŒé …æ¼”ç®—ãƒãƒ¼ãƒ‰ï¼ˆ+, -, *, / ãªã©ï¼‰
  class BinaryOpNode extends ASTNode {
      constructor(left, operator, right) {
          super();
          this.left = left;        // å·¦å´ã®ãƒãƒ¼ãƒ‰
          this.operator = operator; // æ¼”ç®—å­ã®ãƒˆãƒ¼ã‚¯ãƒ³
          this.right = right;      // å³å´ã®ãƒãƒ¼ãƒ‰
      }
      
      accept(visitor) {
          return visitor.visitBinaryOp(this);
      }
      
      toString() {
          return `BinaryOpNode(${this.left.toString()}, ${this.operator.value}, ${this.right.toString()})`;
      }
  }
  
  // å˜é …æ¼”ç®—ãƒãƒ¼ãƒ‰ï¼ˆ-5 ã® - ãªã©ï¼‰
  class UnaryOpNode extends ASTNode {
      constructor(operator, operand) {
          super();
          this.operator = operator; // æ¼”ç®—å­ã®ãƒˆãƒ¼ã‚¯ãƒ³
          this.operand = operand;   // è¢«æ¼”ç®—å­ã®ãƒãƒ¼ãƒ‰
      }
      
      accept(visitor) {
          return visitor.visitUnaryOp(this);
      }
      
      toString() {
          return `UnaryOpNode(${this.operator.value}, ${this.operand.toString()})`;
      }
  }
  
  // ãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆæ§‹æ–‡è§£æå™¨ï¼‰ã‚¯ãƒ©ã‚¹
  class Parser {
      constructor(tokens) {
          this.tokens = tokens.filter(token => token.type !== TokenType.NEWLINE); // æ”¹è¡Œã‚’é™¤å»
          this.position = 0;
          this.currentToken = this.tokens[0] || null;
      }
      
      // ã‚¨ãƒ©ãƒ¼å‡¦ç†
      error(message) {
          const token = this.currentToken;
          if (token) {
              throw new Error(`${message} (è¡Œ${token.line}, åˆ—${token.column})`);
          } else {
              throw new Error(message);
          }
      }
      
      // æ¬¡ã®ãƒˆãƒ¼ã‚¯ãƒ³ã«é€²ã‚€
      advance() {
          this.position++;
          if (this.position < this.tokens.length) {
              this.currentToken = this.tokens[this.position];
          } else {
              this.currentToken = null;
          }
      }
      
      // æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ—ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ¶ˆè²»
      eat(tokenType) {
          if (this.currentToken && this.currentToken.type === tokenType) {
              const token = this.currentToken;
              this.advance();
              return token;
          } else {
              this.error(`Expected ${tokenType}, got ${this.currentToken ? this.currentToken.type : 'EOF'}`);
          }
      }
      
      // factor: æ•°å€¤ | (expression) | -factor | +factor
      factor() {
          const token = this.currentToken;
          
          if (token.type === TokenType.PLUS) {
              this.eat(TokenType.PLUS);
              return new UnaryOpNode(token, this.factor());
          } else if (token.type === TokenType.MINUS) {
              this.eat(TokenType.MINUS);
              return new UnaryOpNode(token, this.factor());
          } else if (token.type === TokenType.NUMBER) {
              this.eat(TokenType.NUMBER);
              return new NumberNode(token);
          } else if (token.type === TokenType.LPAREN) {
              this.eat(TokenType.LPAREN);
              const node = this.expression();
              this.eat(TokenType.RPAREN);
              return node;
          } else {
              this.error(`Unexpected token: ${token.type}`);
          }
      }
      
      // term: factor ((MULTIPLY | DIVIDE) factor)*
      term() {
          let node = this.factor();
          
          while (this.currentToken && 
                 (this.currentToken.type === TokenType.MULTIPLY || 
                  this.currentToken.type === TokenType.DIVIDE)) {
              const operator = this.currentToken;
              this.eat(operator.type);
              node = new BinaryOpNode(node, operator, this.factor());
          }
          
          return node;
      }
      
      // expression: term ((PLUS | MINUS) term)*
      expression() {
          let node = this.term();
          
          while (this.currentToken && 
                 (this.currentToken.type === TokenType.PLUS || 
                  this.currentToken.type === TokenType.MINUS)) {
              const operator = this.currentToken;
              this.eat(operator.type);
              node = new BinaryOpNode(node, operator, this.term());
          }
          
          return node;
      }
      
      // æ§‹æ–‡è§£æã®ãƒ¡ã‚¤ãƒ³ãƒ¡ã‚½ãƒƒãƒ‰
      parse() {
          if (!this.currentToken) {
              return null;
          }
          return this.expression();
      }
  }
  </script>
</body>
</html>
